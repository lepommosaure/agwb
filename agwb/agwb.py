#!/usr/bin/python3
"""@package docstring
Documentation for agwb.py module

Written by Wojciech M. Zabolotny
wzab01<at>gmail.com 18-20.06.2019

The agwb.py module is a helper that provides
access to hierarchy of blocks/registers/bitfields
generated by addr_gen_wb environment, from
the pure Python code, via a simple interface.
The interface must provide two methods:

read(self,address) that returns 32-bit value
write(self,address,value) that writes such a value
"""

class BitField(object):
    """Class delivering an object used to describe the bitfield.

    Its fields contain certain precalculated values supporting quick
    handling of read and write access to the field.
    That class does not provide any methods.
    Only fields are used.
    """
    def __init__(self, msb, lsb, is_signed):
        self.lsb = lsb
        self.msb = msb
        if is_signed:
            self.sign_mask = 1 << (msb-lsb)
            self.vmin = -self.sign_mask
            self.vmax = self.sign_mask-1
        else:
            self.vmin = 0
            self.vmax = (1 << (msb-lsb+1))-1
            self.sign_mask = 0
        self.mask = ((1 << (msb+1)) - 1) ^ ((1<<lsb)-1)


class _BitFieldAccess(object):
    """Class providing a versatile object supporting  read/write access to any bitfield.

    The details of the particular bitfield are hidden in the
    BitField object passed via bf argument.
    """
    def __init__(self, iface, base, bf):
        self.x__iface = iface
        self.x__base = base
        self.x__bf = bf

    def read(self):
        rval = self.x__iface.read(self.x__base)
        rval &= self.x__bf.mask
        rval >>= self.x__bf.lsb
        if self.x__bf.sign_mask:
            if rval & self.x__bf.sign_mask:
                rval -= (self.x__bf.sign_mask << 1)
        return rval

    def write(self, value):
        # Check if the value to be stored is correct
        if (value < self.x__bf.vmin) or (value > self.x__bf.vmax):
            raise Exception("Value doesn't fit in the bitfield")
        # If the bitfield is signed, convert the negative values
        if self.x__bf.sign_mask:
            if value < 0:
                value += (self.x__bf.sign_mask << 1)
                print("final value: "+str(value))
        # Read the whole register
        rval = self.x__iface.read(self.x__base)
        # Mask the bitfield
        rval |= self.x__bf.mask
        rval ^= self.x__bf.mask
        # Shift the new value
        value = value << self.x__bf.lsb
        value &= self.x__bf.mask
        rval |= value
        self.x__iface.write(self.x__base, rval)


class Vector(object):
    """Class describing the vector of registers or subblocks.

    It provides only a __getitem__ method that allows to access the particular object
    in a vector (the object is created on the fly, when it is needed).
    """
    def __init__(self, iface, base, nitems, margs):
        self.iface = iface
        self.base = base
        self.mclass = margs[0]
        self.args = None
        if len(margs) > 1:
            self.args = margs[1]
        self.nitems = nitems

    def __getitem__(self, key):
        if key >= self.nitems:
            raise Exception("Access outside the vector")
        if self.args != None:
            return self.mclass(
                self.iface, \
                self.base+key*self.mclass.x__size, \
                self.args)
        return self.mclass(self.iface, self.base+key*self.mclass.x__size)


class Block(object):
    """ Class describing the blocks handled by addr_gen_wb-gnerated code.

    The Python backend generates derived classes, with class fields
    corresponding to subblocks or registers.
    """
    x__is_blackbox = False
    x__size = 1
    x__fields = {}

    def __init__(self, iface, base):
        """base is the base address for the given block. """
        self.x__base = base
        self.x__iface = iface

    def __dir__(self):
        return self.x__fields.keys()

    def __getattr__(self, name):
        f_i = self.x__fields[name]
        if len(f_i) == 3:
            return Vector(self.x__iface, self.x__base+f_i[0], f_i[1], f_i[2])
        elif len(f_i) == 2:
            if len(f_i[1]) == 1:
                return f_i[1][0](self.x__iface, self.x__base+f_i[0])
            # pass addititional argument to the constructor
            return f_i[1][0](self.x__iface, self.x__base+f_i[0], f_i[1][1])


class _Register(object):
    """Base class supporting access to the register."""
    x__size = 1

    def __init__(self, iface, base, bfields={}):
        self.x__iface = iface
        self.x__base = base
        self.x__bfields = bfields

    def __dir__(self):
        return self.x__bfields.keys()

    def read(self):
        return self.x__iface.read(self.x__base)

    def write(self, value):
        self.x__iface.write(self.x__base, value)

    def __getattr__(self, name):
        return _BitFieldAccess(self.x__iface, self.x__base, self.x__bfields[name])


ControlRegister = _Register # The control register is just the generic register


class StatusRegister(_Register):
    """Class supporting access to the read-only (status) register.

    The write method throws an exception.
    """
    def write(self, value):
        raise Exception("Status register at "+hex(self.x__base)+" can't be written")


"""
Below is the demo code, showing an example how we may access the registers
via an emulated interface.
"""
if __name__ == '__main__':
    # Table emulating the register file
    rf = 1024 * [int(0),]

    # The class iface provides just two methods
    # read(address) and write(address,value)
    class DemoIface(object):
        def __init__(self):
            pass
        def read(self, addr):
            global rf
            print("reading from address:"+hex(addr)+" val="+hex(rf[addr]))
            return rf[addr]
        def write(self, addr, val):
            global rf
            print("writing "+hex(val)+" to address "+hex(addr))
            rf[addr] = val

    class c2(Block):
        x__size = 3
        x__fields = {
            'r1':(1, (StatusRegister,
                      { \
                       't1':BitField(3, 1, False), \
                       't2':BitField(9, 4, True), \
                     }))
        }
    class c1(Block):
        x__size = 100
        x__fields = {
            'f1':(0, 10, (c2,)), \
            'f2':(11, (c2,)), \
            'size':(32, (c2,))
        }

    mf = DemoIface()
    a = c1(mf, 12)
    a.f1[0].r1.t2.write(-3)
    a.f1[0].r1.t1.write(5)
    a.f2.r1.t1.write(7)
    a.f2.r1.t2.write(13)
    print(a.f1[0].r1.t2.read())
    print(a.f1[0].r1.t1.read())
    print(a.f2.r1.t2.read())
    print(a.f2.r1.t1.read())
