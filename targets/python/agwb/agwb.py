#!/usr/bin/python3
"""@package docstring
Documentation for agwb.py module

Written by Wojciech M. Zabolotny
wzab01<at>gmail.com 18-20.06.2019
added support for extended interface:
wzab01<at>gmail.com 2.02.2021

The agwb.py module is a helper that provides
access to hierarchy of blocks/registers/bitfields
generated by addr_gen_wb environment, from
the pure Python code, via a simple interface.
The interface must provide two methods:

read(self,address) that returns 32-bit value
write(self,address,value) that writes such a value

The extended interface (with cached write and read
accesses and support for optimized bitfields
handling and read-modify-write) should provide
additional methods:

writex(self,address,value) - that only schedules 
       a write (unless the operation list is full)
readx(self,address) - that returns the "future" 
       object with "val" field (or method) that returns
       the value (possibly triggering dispatch if necessary)
rmw(self,address,mask,value,now=true) - schedules the read-modify-write
       operation defined as follows
       X:= (X and ~mask) | (value and mask)
       If "now" is true, the new value should be scheduled 
       for writing.
       If "now" is false, the new value should be calculated
       and stored internally by the bus interface.
       The last call to rmw on the particular register should
       have "now" set to "true".
dispatch() - executes the accumulated list of operations
      (the list may be executed automatically, if it grows
      to its full possible length).
"""


class BitField(object):
    """Class delivering an object used to describe the bitfield.

    Its fields contain certain precalculated values supporting quick
    handling of read and write access to the field.
    That class does not provide any methods.
    Only fields are used.
    """

    def __init__(self, msb, lsb, is_signed):
        self.lsb = lsb
        self.msb = msb
        if is_signed:
            self.sign_mask = 1 << (msb - lsb)
            self.vmin = -self.sign_mask
            self.vmax = self.sign_mask - 1
        else:
            self.vmin = 0
            self.vmax = (1 << (msb - lsb + 1)) - 1
            self.sign_mask = 0
        self.mask = ((1 << (msb + 1)) - 1) ^ ((1 << lsb) - 1)


class _BitFieldAccess(object):
    """Class providing a versatile object supporting  read/write access to any bitfield.

    The details of the particular bitfield are hidden in the
    BitField object passed via bf argument.
    """

    def __init__(self, iface, base, bf):
        self.x__iface = iface
        self.x__base = base
        self.x__bf = bf

    def read(self):
        rval = self.x__iface.read(self.x__base)
        rval &= self.x__bf.mask
        rval >>= self.x__bf.lsb
        if self.x__bf.sign_mask:
            if rval & self.x__bf.sign_mask:
                rval -= self.x__bf.sign_mask << 1
        return rval

    def write(self, value):
        # Check if the value to be stored is correct
        if (value < self.x__bf.vmin) or (value > self.x__bf.vmax):
            raise Exception("Value doesn't fit in the bitfield")
        # If the bitfield is signed, convert the negative values
        if self.x__bf.sign_mask:
            if value < 0:
                value += self.x__bf.sign_mask << 1
                print("final value: " + str(value))
        # Read the whole register
        rval = self.x__iface.read(self.x__base)
        # Mask the bitfield
        rval |= self.x__bf.mask
        rval ^= self.x__bf.mask
        # Shift the new value
        value = value << self.x__bf.lsb
        value &= self.x__bf.mask
        rval |= value
        self.x__iface.write(self.x__base, rval)


class Vector(object):
    """Class describing the vector of registers or subblocks.

    It provides only a __getitem__ method that allows to access the particular object
    in a vector (the object is created on the fly, when it is needed).
    """

    def __init__(self, iface, base, nitems, margs):
        self.iface = iface
        self.base = base
        self.mclass = margs[0]
        self.args = None
        if len(margs) > 1:
            self.args = margs[1]
        self.nitems = nitems

    def __getitem__(self, key):
        if key >= self.nitems:
            raise Exception("Access outside the vector")
        if self.args != None:
            return self.mclass(
                self.iface, self.base + key * self.mclass.x__size, self.args
            )
        return self.mclass(self.iface, self.base + key * self.mclass.x__size)


class Block(object):
    """Class describing the blocks handled by addr_gen_wb-gnerated code.

    The Python backend generates derived classes, with class fields
    corresponding to subblocks or registers.
    """

    x__is_blackbox = False
    x__size = 1
    x__fields = {}

    def __init__(self, iface, base):
        """base is the base address for the given block. """
        self.x__base = base
        self.x__iface = iface

    def __dir__(self):
        return self.x__fields.keys()

    def __getattr__(self, name):
        f_i = self.x__fields[name]
        if len(f_i) == 3:
            return Vector(self.x__iface, self.x__base + f_i[0], f_i[1], f_i[2])
        elif len(f_i) == 2:
            if len(f_i[1]) == 1:
                return f_i[1][0](self.x__iface, self.x__base + f_i[0])
            # pass addititional argument to the constructor
            return f_i[1][0](self.x__iface, self.x__base + f_i[0], f_i[1][1])

    def _verify_id(self):
        id = self.ID.read()
        if id != self.x__id:
            raise Exception(
                self.__class__.__name__ + " has ID " + hex(self.x__id) + ", read ID " + hex(id)
            )

    def _verify_ver(self):
        ver = self.VER.read()
        if ver != self.x__ver:
            raise Exception(
                self.__class__.__name__ + " has VER " + hex(self.x__ver) + ", read VER " + hex(ver)
            )

    def verify_id_and_version(self):
        """Read and verify id (ID) and version (VER) registers values.

        This function reads and verifies ID and VER register values
        in a recursive way for all non black box blocks.
        It raises the exception if read values differ as it indicates,
        that software and firmware versions differ.
        """
        for k in self.x__fields.keys():
            subblock = getattr(self, k)
            if not issubclass(type(subblock), Block):
                continue

        if self.x__is_blackbox == False:
            self._verify_id()
            self._verify_ver()


class _Register(object):
    """Base class supporting access to the register."""

    x__size = 1

    def __init__(self, iface, base, bfields={}):
        self.x__iface = iface
        self.x__base = base
        self.x__bfields = bfields

    def __dir__(self):
        return self.x__bfields.keys()

    def read(self):
        return self.x__iface.read(self.x__base)

    def read_fifo(self, count):
        return self.x__iface.read_fifo(self.x__base, count)

    def write(self, value):
        self.x__iface.write(self.x__base, value)

    def write_fifo(self, values):
        self.x__iface.write(self.x__base, values)

    def __getattr__(self, name):
        return _BitFieldAccess(self.x__iface, self.x__base, self.x__bfields[name])


ControlRegister = _Register  # The control register is just the generic register


class StatusRegister(_Register):
    """Class supporting access to the read-only (status) register.

    The write method throws an exception.
    """

    def write(self, value):
        raise Exception("Status register at " + hex(self.x__base) + " can't be written")


"""
Below is the demo code, showing an example how we may access the registers
via an emulated interface.
"""
if __name__ == "__main__":
    # Table emulating the register file
    rf = 1024 * [
        int(0),
    ]

    # The class iface provides just two methods
    # read(address) and write(address,value)
    class DemoIface(object):
        def __init__(self):
            pass

        def read(self, addr):
            global rf
            print("reading from address:" + hex(addr) + " val=" + hex(rf[addr]))
            return rf[addr]

        def write(self, addr, val):
            global rf
            print("writing " + hex(val) + " to address " + hex(addr))
            rf[addr] = val

    class c2(Block):
        x__size = 3
        x__fields = {
            "r1": (
                1,
                (
                    StatusRegister,
                    {"t1": BitField(3, 1, False), "t2": BitField(9, 4, True),},
                ),
            )
        }

    class c1(Block):
        x__size = 100
        x__fields = {"f1": (0, 10, (c2,)), "f2": (11, (c2,)), "size": (32, (c2,))}

    mf = DemoIface()
    a = c1(mf, 12)
    a.f1[0].r1.t2.write(-3)
    a.f1[0].r1.t1.write(5)
    a.f2.r1.t1.write(7)
    a.f2.r1.t2.write(13)
    print(a.f1[0].r1.t2.read())
    print(a.f1[0].r1.t1.read())
    print(a.f2.r1.t2.read())
    print(a.f2.r1.t1.read())
