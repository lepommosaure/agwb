""" 
This is the script that generates the VHDL code needed to access 
the registers in a hierarchical Wishbone-conencted system.

Written by Wojciech M. Zabolotny
(wzab01@gmail.com or wzab@ise.pw.edu.pl)

The code is published under LGPL V2 license

This file implements the class handling a Wishbone connected block
"""

# Template for generation of the VHDL code

templ_header = """\
--- This code is automatically generated by the addrgen_wb.py tool
--- Please don't edit it manaully, unless you really have to do it.

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.wishbone_pkg.all;
library work;

entity {p_entity} is
  generic (
    base_addr : unsigned(31 downto 0);
    valid_bits : integer := {valid_bits};
  );
  port (
    rst_n_i : in std_logic;
    clk_sys_i : in std_logic
    slave_i : t_wishbone_slave_in;
    slave_o : t_wishbone_slave_out;
{subblk_busses}
{signal_ports}
    );

end wb_test_top;

architecture gener of {p_entity} is
{signal_decls}
  -- Internal WB declaration
  signal int_wbs_out : t_wishbone_slave_out;
  signal int_wbs_in : t_wishbone_slave_in;
  signal int_addr : std_logic_vector({valid_bits}-1 downto 0);
  signal wb_s_out : t_wishbone_slave_out_array(0 to {nof_subblks});
  signal wb_s_in : t_wishbone_slave_in_array(0 to {nof_subblks});

  -- Constants
  constant block_id_addr : std_logic_vector({valid_bits}-1 downto 0) := (others => '1');
  constant block_ver_addr : std_logic_vector({valid_bits}-1 downto 0) := (0=>'0', 'others => '1');

begin
  -- Subblocks busses assignments
{subblk_assignments}
  -- Assign the internal WB bus
  int_wbs_out <= wb_s_out(0);
  int_wbs_in <= wb_s_in(0);
  int_addr <= int_wbs_in.adr({valid_bits}-1 downto 0);

-- Main crossbar 
  xwb_crossbar_1: entity work.xwb_crossbar
  generic map (
     g_num_masters => 1,
     g_num_slaves  => 1+nof_subblks,
     g_registered  => {p_registered},
     g_address     => {p_addresses},
     g_mask        => {p_masks})
  port map (
     clk_sys_i => clk_sys_i,
     rst_n_i   => rst_n_i,
     slave_i   => slave_i,
     slave_o   => slave_o,
     master_i  => wb_s_out,
     master_o  => wb_s_in,
    sdb_sel_o => open);

-- Process for register access
  process(clk_sys_i)
  begin
    if rising_edge(clk_sys_i) then
      if rst_n_i = '0' then
        -- Reset of the core
      else
        -- Normal operation
        if (int_wbs_in.cyc = '1') and (int_wbs_in.stb = '1') then
          -- Access, now we handle consecutive registers
          case int_addr is
          {register_access}
          when block_id_addr =>
             wb_s_out.dat <= {block_id};
             wb_s_out.ack <= '1';
          when block_ver_addr =>
             wb_s_out.dat <= {block_ver};
             wb_s_out.ack <= '1';
          when others =>
             wb_s_out.dat <= x"A5A5A5A5";
             wb_s_out.ack <= '1';
          end case;
        end if;
      end if;
    end if;
  end process

"""
blocks={}

class wb_field(object):
   def __init__(self,fl,lsb):
      self.name = fl.attrib['name']
      self.lsb = lsb
      self.size = fl.attrib['width']
      self.msb = lsb + self.size - 1
      self.type = get('type','std_logic_vector')
     
          

class wb_reg(object):
   """ The class wb_reg describes a single register
   """
   def __init__(self,el,adr):
       """
       The constructor gets the XML node defining the register
       """
       nregs=el.get('reps',1)
       self.regtype = el.tag
       self.type = el.get('type','std_logic_vector')
       self.base = adr
       self.size = nregs
       self.name = el.attrib['name']
       self.ack = el.get('ack',0)
       self.stb = el.get('stb',0)
       # Read list of fields
       self.fields=[]
       self.free_bit=0
       for fl in el.findall('field')
           fdef=wb_field(fl,self.free_bit)
           self.free_bit += fdef.size
           if self.free_bit > 32:
              raise Exception("Total width of fields in register " +self.name+ " is above 32-bits")
           self.fields.append(fdef)
       

   def gen_vhdl(self,parent):
       """
       The method generates the VHDL block responsible for access
       to the registers.
       We append our definitions to the appropriate sections
       in the parrent block.
       
       We need to generate two sections:
       * Declaration of signals used to input or output the signal,
          and the optoional ACK or STB flags
       * Read or write sequence to be embedded in the process
       """
       # Generate the type corresponding to the register
       tname = "t_"+self.name
       if len(self.fields) == 0:
          # Simple register, no fields
          dt="subtype "+tname+" is "+\
             self.type+"(31 downto 0);\n" 
       else:
          # Register with fields, we have to create a record
          dt="type "+tname+" is record\n"
          for fl in self.fields:
             dt+= "  "+fl.vhdl_type()+";\n"
          dt+="end record;\n"
       # If this is a vector of registers, create the array type
       if self.size > 1:
          dt+="type "+tname+"_array is array(0 to "+ str(self.size-1) +") of "+tname+";\n"
       # Append the generated types to the parents package section
       parent.add_templ('p_package',dt,4)

       # Now generate the entity ports
       sfx = '_i'
       sdir = "in "
       if self.type == 'creg':
         sfx = '_o'
         sdir = "out "
       if self.size == 1:
          dt=self.name+sfx+" : "+sdir+" "+tname+";\n"
       else:
          dt=self.name+sfx+" : "+sdir+" "+tname+"_array;\n"
       # Now we generate the STB or ACK ports (if required)
       if self.type == 'creg' and self.stb == 1:
          # We need to generate STB output
          pass # To be implemented!
       if self.type == 'sreg' and self.ack == 1:
          # We need to generate ACK output
          pass # To be implemented!          
       parent.add_templ('signal_ports',dt,4)
       # Generate the intermediate signals for output ports
       # (because they can't be read back)
       pass # To be implemented
       # Generate the signal assignment in the process
       pass # To be implemented
 
   def gen_pkg(self):
     """
     The method generates the VHDL package code.
     For example the record type to access the bitfields.
     """
     pass

class wb_area(object):
    """ The class representing the address area
    """
    def __init__(self,size,obj,reps):
        self.size=size
        self.obj=obj
        self.adr=0
        self.mask=0
        self.total_size=0
        self.reps=reps
    def sort_key(self):
        return self.size
    
class wb_block(object):
   def __init__(self,el):
     """
     The constructor takes an XML node that describes the block
     It also calculates the number of registers, and creates
     the description of the record
     """
     self.name = el.attrib['name']
     # We prepare the list of address areas
     self.areas=[]
     # We prepare the table for storing the registers.
     self.regs=[]
     self.free_reg_addr=0 # The first free address
     # Prepare the list of subblocks
     self.subblks=[]
     for child in el.findall("*"):
         # Now for registers we allocate addresses in order
         # We don't to alignment (yet)
        if child.tag == 'creg':
            # This is a control register
           reg = wb_reg(child,self.free_reg_addr)
           self.free_reg_addr += reg.size
           self.regs.append(reg)
        elif child.tag == 'sreg':
            # This is a status register
           reg = wb_reg(child,self.free_reg_addr)
           self.free_reg_addr += reg.size
           self.regs.append(reg)
        elif child.tag == 'subblock':
            # This is a subblock definition
            # We only add it to the list, the addresses can't be allocated yet
           self.subblks.append(child)
        else:
            # Unknown child
           raise Exception("Unknown node in block: "+el.name)
       # After that procedure, the field free_reg_addr contains
       # the length of the block of internal registers
       
   def analyze(self):
     # Add the length of the local addresses to the list of areas
     self.areas.append(wb_area(self.free_reg_addr, None,1))
     # Scan the subblocks
     for sblk in self.subblks:
        #@!@ Here we must to correct something! The name of the subblock
        #Is currently lost. We must to decide how it should be passed
        #To the generated code@!@
        bl = blocks[sblk.attrib['type']]
        # If the subblock was not analyzed yet, analyze it now
        if len(bl.areas)==0:
            bl.analyze()
            # Now we can be sure, that it is analyzed, so we can 
            # add its address space to ours.
        # Check if this is a vector of subblocks
        reps = sblk.get('reps',1)
        print("reps:"+str(reps))
        # Now recalculate the size of the area, considering possible
        # block repetitions
        addr_size = bl.addr_size * reps
        self.areas.append(wb_area(addr_size,bl,reps))
     # Now we can calculate the total length of address space
     # We use the simplest algorithm - all blocks are sorted,
     # their size is rounded up to the nearest power of 2
     # They are allocated in order.
     cur_base = 0
     self.areas.sort(key=wb_area.sort_key, reverse=True)
     for ar in self.areas:
         if ar.obj==None:
             # This is the register block
             self.reg_base = cur_base
         ar.adr = cur_base
         ar.adr_bits = (ar.size-1).bit_length()
         ar.total_size = 1 << ar.adr_bits
         # Now we shift the position of the next block
         cur_base += ar.total_size
         print("added size:"+str(ar.total_size))
     self.addr_size = cur_base
     # We must adjust the address space to the power of two
     self.adr_bits = (self.addr_size-1).bit_length()
     self.addr_size = 1 << self.adr_bits
     # In fact, here we should be able to generate the HDL code
     
     print('analyze: '+self.name+" addr_size:"+str(self.addr_size))

#@!@ How to represent base addresses for subblocks in vectors?
   def add_templ(self,templ_key,value):
       """ That function adds the new text to the dictionary
           used to fill the templates for code generation.
       """
       pass # To be implemented!
     
   def gen_vhdl(self):
       # To fill the template, we must to set the following values:
       # p_entity, valid_bits
       
       # subblk_busses, signal_ports, signal_decls
       # nof_subblks,
       # subblk_assignments,
       # n_slaves,
       # p_registered,
       # p_addresses, p_masks
       # block_id, block_ver - to verify that design matches the software

       # First - generate code for registers
       signal_ports=""
       for reg in regs:
          #generate 
          if reg.reps=1
             
        
       pass
