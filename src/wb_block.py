""" 
This is the script that generates the VHDL code needed to access 
the registers in a hierarchical Wishbone-conencted system.

Written by Wojciech M. Zabolotny
(wzab01@gmail.com or wzab@ise.pw.edu.pl)

The code is published under LGPL V2 license

This file implements the class handling a Wishbone connected block
"""

# Template for generation of the VHDL code

templ_header = """\
--- This code is automatically generated by the addrgen_wb.py tool
--- Please don't edit it manaully, unless you really have to do it.

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.wishbone_pkg.all;
library work;

entity {p_entity} is
  generic (
    base_addr : unsigned(31 downto 0);
    valid_bits : integer := {valid_bits};
  );
  port (
    rst_n_i : in std_logic;
    clk_sys_i : in std_logic
    slave_i : t_wishbone_slave_in;
    slave_o : t_wishbone_slave_out;
{subblk_busses}
{signal_ports}
    );

end wb_test_top;

architecture gener of {p_entity} is
{signal_decls}
  -- Internal WB declaration
  signal int_wbs_out : t_wishbone_slave_out;
  signal int_wbs_in : t_wishbone_slave_in;
  signal int_addr : std_logic_vector({valid_bits}-1 downto 0);
  signal wb_s_out : t_wishbone_slave_out_array(0 to {nof_subblks});
  signal wb_s_in : t_wishbone_slave_in_array(0 to {nof_subblks});

  -- Constants
  constant block_id_addr : std_logic_vector({valid_bits}-1 downto 0) := (others => '1');
  constant block_ver_addr : std_logic_vector({valid_bits}-1 downto 0) := (0=>'0', 'others => '1');

begin
  -- Subblocks busses assignments
{subblk_assignments}
  -- Assign the internal WB bus
  int_wbs_out <= wb_s_out(0);
  int_wbs_in <= wb_s_in(0);
  int_addr <= int_wbs_in.adr({valid_bits}-1 downto 0);

-- Main crossbar 
  xwb_crossbar_1: entity work.xwb_crossbar
  generic map (
     g_num_masters => 1,
     g_num_slaves  => 1+nof_subblks,
     g_registered  => {p_registered},
     g_address     => {p_addresses},
     g_mask        => {p_masks})
  port map (
     clk_sys_i => clk_sys_i,
     rst_n_i   => rst_n_i,
     slave_i   => slave_i,
     slave_o   => slave_o,
     master_i  => wb_s_out,
     master_o  => wb_s_in,
    sdb_sel_o => open);

-- Process for register access
  process(clk_sys_i)
  begin
    if rising_edge(clk_sys_i) then
      if rst_n_i = '0' then
        -- Reset of the core
      else
        -- Normal operation
        if (int_wbs_in.cyc = '1') and (int_wbs_in.stb = '1') then
          -- Access, now we handle consecutive registers
          case int_addr is
          {register_access}
          when block_id_addr =>
             wb_s_out.dat <= {block_id};
             wb_s_out.ack <= '1';
          when block_ver_addr =>
             wb_s_out.dat <= {block_ver};
             wb_s_out.ack <= '1';
          when others =>
             wb_s_out.dat <= x"A5A5A5A5";
             wb_s_out.ack <= '1';
          end case;
        end if;
      end if;
    end if;
  end process

"""
blocks={}

class wb_reg(object):
   """ The class wb_reg describes a single register
   """
   def __init__(self,el,adr):
       """
       The constructor gets the XML node defining the register
       """
       nregs=1
       if 'reps' in el.attrib:
           nregs = int(el.attrib['reps'])
       self.base = adr;
       self.size = nregs
       self.name = el.attrib['name']
       self.ack = 0
       if 'ack' in el.attrib:
           self.ack = int(el.attrib['ack'])
       self.stb = 0
       if 'stb' in el.attrib:
           self.stb = int(el.attrib['stb'])
           
       

   def gen_vhdl(self):
       """
       The method generates the VHDL block responsible for access
       to the registers.
       We need to generate two sections:
       * Declaration of signals used to input or output the signal,
          and the optoional ACK or STB flags
       * Read or write sequence to be embedded in the process
       """
       pass

   def gen_pkg(self):
     """
     The method generates the VHDL package code.
     For example the record type to access the bitfields.
     """
     pass

class wb_area(object):
    """ The class representing the address area
    """
    def __init__(self,size,obj):
        self.size=size
        self.obj=obj
        self.adr=0
        self.mask=0
        self.total_size=0
    def sort_key(self):
        return self.size
    
class wb_block(object):
   def __init__(self,el):
     """
     The constructor takes an XML node that describes the block
     It also calculates the number of registers, and creates
     the description of the record
     """
     self.name = el.attrib['name']
     # We prepare the list of address areas
     self.areas=[]
     # We prepare the table for storing the registers.
     self.regs=[]
     self.free_reg_addr=0 # The first free address
     # Prepare the list of subblocks
     self.subblks=[]
     for child in el.findall("*"):
         # Now for registers we allocate addresses in order
         # We don't to alignment (yet)
        if child.tag == 'creg':
            # This is a control register
           reg = wb_reg(child,self.free_reg_addr)
           self.free_reg_addr += reg.size
           self.regs.append(reg)
        elif child.tag == 'sreg':
            # This is a status register
           reg = wb_reg(child,self.free_reg_addr)
           self.free_reg_addr += reg.size
           self.regs.append(reg)
        elif child.tag == 'subblock':
            # This is a subblock definition
            # We only add it to the list, the addresses can't be allocated yet
           self.subblks.append(child)
        else:
            # Unknown child
           raise Exception("Unknown node in block: "+el.name)
       # After that procedure, the field free_reg_addr contains
       # the length of the block of internal registers
        
   def analyze(self):
     # Add the length of the local addresses to the list of areas
     self.areas.append(wb_area(self.free_reg_addr, None))
     # Scan the subblocks
     for sblk in self.subblks:
        #@!@ Here we must to correct something! The name of the subblock
        #Is currently lost. We must to decide how it should be passed
        #To the generated code@!@
        bl = blocks[sblk.attrib['type']]
        # If the subblock was not analyzed yet, analyze it now
        if len(bl.areas)==0:
            bl.analyze()
            # Now we can be sure, that it is analyzed, so we can 
            # add its address space to ours.
        self.areas.append(wb_area(bl.addr_size,bl))
        # Now we can calculate the total length of address space
        # We use the simplest algorithm - all blocks are sorted,
        # their size is rounded up to the nearest power of 2
        # They are allocated in order.
     cur_base = 0
     self.areas.sort(key=wb_area.sort_key, reverse=True)
     for ar in self.areas:
         if ar.obj==None:
             # This is the register block
             self.reg_base = cur_base
         ar.adr = cur_base
         ar.adr_bits = (ar.size-1).bit_length()
         ar.total_size = 1 << ar.adr_bits
         # Now we shift the position of the next block
         cur_base += ar.total_size
         self.addr_size = cur_base
           
     print('analyze: '+self.name+" addr_size:"+str(self.addr_size))
     
   def gen_vhdl(self):
       # To fill the template, we must to set the following values:
       # p_entity, valid_bits
       
       # subblk_busses, signal_ports, signal_decls
       # nof_subblks,
       # subblk_assignments,
       # n_slaves,
       # p_registered,
       # p_addresses, p_masks
       # block_id, block_ver - to verify that design matches the software
       pass
