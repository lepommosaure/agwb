""" 
This is the script that generates the VHDL code needed to access 
the registers in a hierarchical Wishbone-conencted system.

Written by Wojciech M. Zabolotny
(wzab01@gmail.com or wzab@ise.pw.edu.pl)

The code is published under LGPL V2 license

This file implements the class handling a Wishbone connected block
"""

# Template for generation of the VHDL code

templ_header = """\
--- This code is automatically generated by the addrgen_wb.py tool
--- Please don't edit it manaully, unless you really have to do it.

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.wishbone_pkg.all;
library work;

entity {p_entity} is
  generic (
    base_addr : unsigned(31 downto 0);
    valid_bits : integer := {valid_bits};
  );
  port (
    rst_n_i : in std_logic;
    clk_sys_i : in std_logic
    slave_i : t_wishbone_slave_in;
    slave_o : t_wishbone_slave_out;
{subblk_busses}
{signal_cons}
    );

end wb_test_top;

architecture gener of {p_entity} is
{signal_decls}
  -- Internal WB declaration
  signal int_wbs_out : t_wishbone_slave_out;
  signal int_wbs_in : t_wishbone_slave_in;
  signal int_addr : std_logic_vector({valid_bits}-1 downto 0);
  -- Constants
  constant block_id_addr : std_logic_vector({valid_bits}-1 downto 0) := (others => '1');
  constant block_ver_addr : std_logic_vector({valid_bits}-1 downto 0) := (0=>'0', 'others => '1');

begin
  -- Subblocks busses assignments
{subblk_assignments}
  -- Assign the internal WB bus
  int_wbs_out <= wb_s_out(0);
  int_wbs_in <= wb_s_in(0);
  int_addr <= int_wbs_in.adr({valid_bits}-1 downto 0);

-- Main crossbar 
  xwb_crossbar_1: entity work.xwb_crossbar
  generic map (
     g_num_masters => {n_masters},
     g_num_slaves  => {n_slaves},
     g_registered  => {p_registered},
     g_address     => {p_address} ,
     g_mask        => {p_mask})
  port map (
     clk_sys_i => clk_sys_i,
     rst_n_i   => rst_n_i,
     slave_i   => wb_m_out,
     slave_o   => wb_m_in,
     master_i  => wb_s_out,
     master_o  => wb_s_in,
    sdb_sel_o => open);

-- Process for register access
  process(clk_sys_i)
  begin
    if rising_edge(clk_sys_i) then
      if rst_n_i = '0' then
        -- Reset of the core
      else
        -- Normal operation
        if (int_wbs_in.cyc = '1') and (int_wbs_in.stb = '1') then
          -- Access, now we handle consecutive registers
          case int_addr is
          {register_access}
          when block_id_addr =>
             wb_s_out.dat <= {block_id};
             wb_s_out.ack <= '1';
          when block_ver_addr =>
             wb_s_out.dat <= {block_ver};
             wb_s_out.ack <= '1';
          when others =>
             wb_s_out.dat <= x"A5A5A5A5";
             wb_s_out.ack <= '1';
          end case;
        end if;
      end if;
    end if;
  end process

"""

templ_wb_crb = """\
"""


class wb_reg(object):
    """ The class wb_reg describes a single register
    """

   def __init__(self,el):
     """
     The constructor gets the XML node defining the register
     """
     pass

   def gen_vhdl(self):
     """
     The method generates the VHDL block responsible for access
     to the registers.
     """


   def gen_pkg(self):
     """
     The method generates the VHDL package code.
     For example the record type to access the bitfields.
     """
     pass

class wb_block(object):
   def __init__(self,el):
     """
     The constructor takes an XML node that describes the block
     It also calculates the number of registers, and creates
     the description of the record
     """
     # We prepare the table for storing the registers.
     self.adrmap=[]
     self.free_addr=0 # The first free address
     # Prepare the list of subblocks
     self.subblks=[]
     for child in el.findall("*"):
        if child.tag == 'creg':
           # This is a control register
           
           pass
        elif child.tag == 'sreg':
           # This is a status register
           pass
        elif child.tag == 'subblock':
           # This is a subblock definition
           pass
        else:
           # Unknown child
           raise Exception("Unknown node in block: "+el.name)
   def analyze(self):
     # Prepare the map of address areas
     self.areas=[]
     # Do the local stuff
     # Scan the subblocks
     for bl in self.subblks[]:
        # If the subblock was not analyzed yet, analyze it now
        bl.analyze()
        # Now we can be sure, that it is analyzed, so we can 
        # add its address space to ours.
        
